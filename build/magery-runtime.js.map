{"version":3,"sources":["webpack:///webpack/bootstrap b7c17eabce8e3ad0db81","webpack:///./src/magery-runtime.js","webpack:///./src/patch.js","webpack:///./src/transforms.js","webpack:///./src/html.js","webpack:///./src/utils.js"],"names":[],"mappings":";;AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;ACtCA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACTA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oCAAmC,SAAS;AAC5C;AACA;AACA;AACA;AACA;AACA,qCAAoC,SAAS;AAC7C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAmC;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2CAA0C,SAAS;AACnD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC7RA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;ACjEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5BA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA,uCAAsC,SAAS;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA8B;AAC9B;;AAEA;AACA;AACA,kDAAiD,SAAS;AAC1D;AACA;AACA","file":"magery-runtime.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap b7c17eabce8e3ad0db81","var Patcher = require('./patch').Patcher;\n\nexports._template = function (render) {\n    var f = function (node, data, handlers) {\n        var patcher = new Patcher(node);\n        return render.call(this, patcher, data, handlers);\n    };\n    f._render = render;\n    return f;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/magery-runtime.js\n// module id = 0\n// module chunks = 0","/**\n * Processes render events (e.g. enterTag, exitTag) and matches them against the\n * current state of the DOM. Where there is a mismatch a transform function is\n * called to reconcile the differences. The Patcher code should only _read_ the\n * DOM, performing DOM mutation only through transform calls.\n */\n\nvar transforms = require('./transforms');\nvar utils = require('./utils');\nvar html = require('./html');\n\nvar ELEMENT_NODE = 1;\nvar TEXT_NODE = 3;\n\n\nfunction matches(node, tag, key) {\n    return (\n        node.tagName === tag ||\n        node.nodeType === TEXT_NODE && tag === '#text'\n    ) && node.key == key;\n};\n\nfunction align(parent, node, tag, key) {\n    if (node && matches(node, tag, key)) {\n        return node;\n    }\n    if (key && parent.keymap) {\n        return parent.keymap[key] || null;\n    }\n    return null;\n};\n\n// deletes all children in parent starting from node (inclusive)\nfunction deleteChildren(transforms, parent, node) {\n    while (node) {\n        var tmp = node;\n        node = node.nextSibling;\n        transforms.removeChild(parent, tmp);\n    }\n}\n\nfunction deleteUnvisitedAttributes(transforms, node) {\n    var attrs = node.attributes;\n    var remove = [];\n    var i, len;\n    for (i = 0, len = attrs.length; i < len; i++) {\n        var attr = attrs[i];\n        if (!node.visited_attributes.hasOwnProperty(attr.name)) {\n            remove.push(attr.name);\n        }\n    }\n    for (i = 0, len = remove.length; i < len; i++) {\n        transforms.removeAttribute(node, remove[i]);\n    }\n};\n\n// deletes children not marked as visited during patch\nfunction deleteUnvisitedEvents(transforms, node) {\n    if (!node.bound_events) {\n        return;\n    }\n    for (var type in node.bound_events) {\n        if (!node.visited_events.hasOwnProperty(type)) {\n            transforms.removeEventListener(node, type, node.bound_events[type].fn);\n            delete node.bound_events[type];\n        }\n    }\n};\n\n\nfunction Patcher(element, custom_transforms) {\n    this.transforms = custom_transforms || transforms;\n    this.root = element;\n    this.reset();\n};\n\nexports.Patcher = Patcher;\n\nPatcher.prototype.reset = function () {\n    this.parent = this.root.parentNode;\n    this.current = this.root;\n};\n\nPatcher.prototype.stepInto = function (node) {\n    node.visited_attributes = {};\n    node.visited_events = {};\n    this.parent = node;\n    this.current = node.firstChild;\n};\n\nPatcher.prototype.enterTag = function (tag, key) {\n    var node = align(this.parent, this.current, tag, key);\n    if (!node) {\n        node = this.transforms.insertElement(this.parent, this.current, tag);\n        if (key) {\n            if (!this.parent.keymap) {\n                this.parent.keymap = {};\n            }\n            this.parent.keymap[key] = node;\n            node.key = key;\n        }\n    }\n    else if (!this.current) {\n        this.transforms.appendChild(this.parent, node);\n    }\n    else if (node !== this.current) {\n        this.transforms.replaceChild(this.parent, node, this.current);\n    }\n    if (!this.template_root) {\n        this.template_root = node;\n    }\n    this.stepInto(node);\n};\n\n// specific value for referncing an event inside handler arguments\nPatcher.prototype.EVENT = {};\n\nfunction makeHandler(node, type) {\n    return function (event) {\n        var handler = node.bound_events[type];\n        if (handler.path) {\n            var context = utils.shallowClone(handler.data);\n            context.event = event;\n            with (context) {\n                var args = eval(handler.args);\n            }\n            var fn = utils.lookup(node.handlers, handler.path);\n            if (!fn) {\n                throw new Error(\n                    \"on\" + type + \": no '\" + handler.path.join('.') + \"' handler defined\"\n                );\n            }\n            fn.apply(handler.template_root, args);\n        }\n    };\n}\n\nfunction setListener(node, type) {\n    if (!node.bound_events) {\n        node.bound_events = {};\n    }\n    if (!node.bound_events.hasOwnProperty(type)) {\n        var fn = makeHandler(node, type);\n        node.bound_events[type] = {fn: fn};\n        transforms.addEventListener(node, type, fn);\n    }\n    node.visited_events[type] = null;\n}\n\nPatcher.prototype.eventListener = function (type, handler_path, args, data, handlers) {\n    var node = this.parent;\n    if (node.handlers !== handlers) {\n        node.handlers = handlers;\n    }\n    setListener(node, type);\n    var event = node.bound_events[type];\n    event.path = handler_path;\n    event.args = args;\n    event.data = data;\n    event.template_root = this.template_root;\n};\n\n// Patcher.prototype.attribute = function (name, value) {\n//     var node = this.parent;\n//     console.log(['attribute', name, node.getAttribute(name), value, node.value]);\n//     if (html.attributes[name] & html.USE_PROPERTY) {\n//         if (node[name] !== value) {\n//             if (html.attributes[name] & html.USE_STRING) {\n//                 value = '' + value;\n//             }\n//             this.transforms.setAttribute(node, name, value);\n//         }\n//     }\n//     else if (node.getAttribute(name) !== '' + value) {\n//         this.transforms.setAttribute(node, name, value);\n//     }\n//     node.visited_attributes.add(name);\n// };\n// TODO: add unit tests to justify some of the above logic\nPatcher.prototype.attribute = function (name, value) {\n    var node = this.parent;\n    if (node.getAttribute(name) !== value) {\n        this.transforms.setAttribute(node, name, value);\n    }\n    node.visited_attributes[name] = null;\n};\n\nPatcher.prototype.text = function (text) {\n    var node = align(this.parent, this.current, '#text', null);\n    if (!node) {\n        node = this.transforms.insertTextNode(this.parent, this.current, text);\n    }\n    else if (node.textContent !== text) {\n        this.transforms.replaceText(node, text);\n    }\n    this.current = node.nextSibling;\n};\n\nfunction getListener(node, type) {\n    return node.bound_events &&\n        node.bound_events[type] &&\n        node.bound_events[type].fn;\n}\n\nPatcher.prototype.exitTag = function () {\n    // delete unvisited child nodes\n    if (this.parent.tagName !== 'TEXTAREA') {\n        deleteChildren(this.transforms, this.parent, this.current);\n    }\n    var node = this.parent;\n    this.parent = node.parentNode;\n    this.current = node.nextSibling;\n    deleteUnvisitedAttributes(this.transforms, node);\n    deleteUnvisitedEvents(this.transforms, node);\n};\n\nPatcher.prototype.skip = function (tag, key) {\n    var node = align(this.parent, this.current, tag, key);\n    if (!this.current) {\n        this.transforms.appendChild(this.parent, node);\n    }\n    else if (node !== this.current) {\n        this.transforms.replaceChild(this.parent, node, this.current);\n    }\n    this.current = node.nextSibling;\n};\n\nPatcher.prototype.lookup = utils.lookup;\n\nPatcher.prototype.isTruthy = function (x) {\n    if (Array.isArray(x)) {\n        return x.length > 0;\n    }\n    return x;\n};\n\nPatcher.prototype.each = function (data, name, iterable, f) {\n    for (var i = 0, len = iterable.length; i < len; i++) {\n        var data2 = utils.shallowClone(data);\n        data2[name] = iterable[i];\n        f(data2);\n    }\n};\n\nPatcher.prototype.render = function (templates, name, data, handlers, root_key, root_attrs, inner) {\n    if (!templates[name]) {\n        this.enterTag(name.toUpperCase(), null);\n        this.exitTag();\n        return;\n    }\n    var template = templates[name];\n    if (template._render) {\n        // it's a compiled magery template\n        var tmp = this.template_root;\n        this.template_root = null;\n        template._render.call(templates, this, data, handlers, root_key, root_attrs, inner);\n        this.template_root = tmp;\n    }\n    else {\n        // it's a custom template function\n        this.enterTag(name.toUpperCase(), null);\n        // bind any event handlers added to custom tag call:\n        root_attrs();\n        template(this.parent, data, handlers, inner);\n        // do exitTag *without* cleaning up unvisited nodes/attributes/etc\n        var node = this.parent;\n        this.parent = node.parentNode;\n        this.current = node.nextSibling;\n    }\n};\n\n\nPatcher.prototype.wrapChildren = function (fn) {\n    var self = this;\n    return function (parent) {\n        if (parent) {\n            var p = new Patcher(parent);\n            p.parent = parent;\n            p.current = parent.firstChild;\n            fn(p);\n        }\n        else {\n            fn(self);\n        }\n    };\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/patch.js\n// module id = 1\n// module chunks = 0","/**\n * DOM mutation procedures called by the patcher. This module provides\n * a cleaner API for our purposes and a place to intercept and\n * monitor mutations during testing.\n */\n\nvar html = require('./html');\n\n\nexports.insertTextNode = function (parent, before, str) {\n    var node = document.createTextNode(str);\n    parent.insertBefore(node, before);\n    return node;\n};\n\nexports.replaceText = function (node, str) {\n    node.textContent = str;\n    return node;\n};\n\nexports.replaceChild = function (parent, node, old) {\n    parent.replaceChild(node, old);\n    return node;\n};\n\nexports.appendChild = function (parent, node) {\n    parent.appendChild(node);\n    return node;\n};\n\nexports.insertElement = function (parent, before, tag) {\n    var node = document.createElement(tag);\n    parent.insertBefore(node, before);\n    return node;\n};\n\nexports.removeChild = function (parent, node) {\n    parent.removeChild(node);\n    return node;\n};\n\nexports.setAttribute = function (node, name, value) {\n    if (html.attributes[name] & html.USE_PROPERTY) {\n        node[name] = value;\n    }\n    node.setAttribute(name, value);\n    return node;\n};\n\nexports.removeAttribute = function (node, name) {\n    if (html.attributes[name] & html.USE_PROPERTY) {\n        node[name] = false;\n    }\n    node.removeAttribute(name);\n    return node;\n};\n\nexports.addEventListener = function (node, name, handler) {\n    node.addEventListener(name, handler, false);\n    return node;\n};\n\nexports.removeEventListener = function (node, name, handler) {\n    node.removeEventListener(name, handler);\n    return node;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/transforms.js\n// module id = 2\n// module chunks = 0","var BOOLEAN_ATTRIBUTE = exports.BOOLEAN_ATTRIBUTE = 1;\nvar USE_PROPERTY = exports.USE_PROPERTY = 2;\nvar USE_STRING = exports.USE_STRING = 4;\n\nexports.attributes = {\n    'allowfullscreen': BOOLEAN_ATTRIBUTE,\n    'async': BOOLEAN_ATTRIBUTE,\n    'autofocus': BOOLEAN_ATTRIBUTE,\n    'autoplay': BOOLEAN_ATTRIBUTE,\n    'capture': BOOLEAN_ATTRIBUTE,\n    'checked': BOOLEAN_ATTRIBUTE | USE_PROPERTY,\n    'controls': BOOLEAN_ATTRIBUTE,\n    'default': BOOLEAN_ATTRIBUTE,\n    'defer': BOOLEAN_ATTRIBUTE,\n    'disabled': BOOLEAN_ATTRIBUTE,\n    'formnovalidate': BOOLEAN_ATTRIBUTE,\n    'hidden': BOOLEAN_ATTRIBUTE,\n    'itemscope': BOOLEAN_ATTRIBUTE,\n    'loop': BOOLEAN_ATTRIBUTE,\n    'multiple': BOOLEAN_ATTRIBUTE | USE_PROPERTY,\n    'muted': BOOLEAN_ATTRIBUTE | USE_PROPERTY,\n    'novalidate': BOOLEAN_ATTRIBUTE,\n    'open': BOOLEAN_ATTRIBUTE,\n    'readonly': BOOLEAN_ATTRIBUTE,\n    'required': BOOLEAN_ATTRIBUTE,\n    'reversed': BOOLEAN_ATTRIBUTE,\n    'selected': BOOLEAN_ATTRIBUTE | USE_PROPERTY,\n    'value': USE_PROPERTY | USE_STRING\n};\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/html.js\n// module id = 3\n// module chunks = 0","var ELEMENT_NODE = 1;\nvar TEXT_NODE = 3;\nvar DOCUMENT_FRAGMENT = 11;\n\nexports.isDocumentFragment = function (node) {\n    return node.nodeType === DOCUMENT_FRAGMENT;\n};\n\nexports.isElementNode = function (node) {\n    return node.nodeType === ELEMENT_NODE;\n};\n\nexports.isTextNode = function (node) {\n    return node.nodeType === TEXT_NODE;\n};\n\nexports.eachNode = function (nodelist, f) {\n    var i = 0;\n    var node = nodelist[0];\n    while (node) {\n        var tmp = node;\n        // need to call nextSibling before f() because f()\n        // might remove the node from the DOM\n        node = node.nextSibling;\n        f(tmp, i++, nodelist);\n    }\n};\n\nexports.mapNodes = function (nodelist, f) {\n    var results = [];\n    exports.eachNode(nodelist, function (node, i) {\n        results[i] = f(node, i, nodelist);\n    });\n    return results;\n};\n\nexports.trim = function (str) {\n    return str.replace(/^\\s+|\\s+$/g, '');\n};\n\nexports.propertyPath = function (str) {\n    return str.split('.').filter(function (x) {\n        return x;\n    });\n};\n\n// finds property path array (e.g. ['foo', 'bar']) in data object\nexports.lookup = function (data, props) {\n    var value = data;\n    for(var i = 0, len = props.length; i < len; i++) {\n        if (value === undefined || value === null) {\n            return '';\n        }\n        value = value[props[i]];\n    }\n    return (value === undefined || value === null) ? '' : value;\n};\n\nexports.templateTagName = function (node) {\n    var m = /^TEMPLATE-([^\\s/>]+)/.exec(node.tagName);\n    return m && m[1].toLowerCase();\n};\n\nexports.shallowClone = function (obj) {\n    var result = {};\n    for (var k in obj) {\n        result[k] = obj[k];\n    }\n    return result;\n    // return Object.assign({}, obj);\n};\n\nexports.eachAttribute = function (node, f) {\n    var attrs = node.attributes;\n    for (var i = 0, len = node.attributes.length; i < len; i++) {\n        f(node.attributes[i].name, node.attributes[i].value);\n    }\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/utils.js\n// module id = 4\n// module chunks = 0"],"sourceRoot":""}